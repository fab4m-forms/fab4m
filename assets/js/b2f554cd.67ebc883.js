"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/01/28/remix-with-fab4m","metadata":{"permalink":"/blog/2023/01/28/remix-with-fab4m","source":"@site/blog/2023-01-28-remix-with-fab4m.md","title":"Remix and fab4m","description":"Remix and fab4m work great together thanks to it\'s compatibility with react router. Let\'s dive in!","date":"2023-01-28T00:00:00.000Z","formattedDate":"January 28, 2023","tags":[],"readingTime":8.66,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Remix and fab4m","description":"Remix and fab4m work great together thanks to it\'s compatibility with react router. Let\'s dive in!"},"nextItem":{"title":"Fab4m and Laravel: Creating a simple form builder","permalink":"/blog/2022/12/18/form-builder-with-laravel"}},"content":"[Remix](https://remix.run/) is a great node framework to render react components server side. It\\ncomes with some really great ways of handling loading and saving data and\\nit has recently become completely compatible with the popular [React Router](https://reactrouter.com/en/main) library.\\n\\nFab4m comes with a support package to support react router which means\\nit also works with remix. This let\'s you offload a lot of the work\\nthat is normally done on the client to the server side!\\n\\nThis blog post illustrates how fab4m can be used together with Remix.\\nI won\'t go into great detail on how remix works, for that you can\\ncheck their excellent documentation!\\n\\n\x3c!--truncate--\x3e\\n\\n## Set up a new remix project\\n\\nRemix comes with a few different stacks. We\'re going to use the indie stack\\nhere which is really easy to get started with since it relies only on sqlite.\\n\\nnpx create-remix@latest --template remix-run/indie-stack fab4m-remix\\n\\n## Clean up the boiler plate\\n\\nThe boilerplate code comes with some neat things that we don\'t need in this simple app, like an example entry model and authentication. We\'re going to start with stripping that out.\\n\\n```bash\\nrm -r app/routes/notes/\\napp/routes/notes.tsx\\napp/routes/join.tsx\\napp/routes/login.tsx\\napp/routes/logout.tsx\\napp/models/note.server.ts\\napp/models/user.server.ts\\napp/session.server.ts\\napp/utils.ts\\napp/utils.test.ts\\n```\\n\\nchange root.tsx so that it looks like this, not that we also added the fab4m stylesheet:\\n\\n```jsx\\nimport type { LinksFunction, LoaderArgs, MetaFunction } from \\"@remix-run/node\\";\\nimport {\\n  Links,\\n  LiveReload,\\n  Meta,\\n  Outlet,\\n  Scripts,\\n  ScrollRestoration,\\n} from \\"@remix-run/react\\";\\nimport fab4mStyleUrl from \\"@fab4m/fab4m/css/basic/basic.css\\";\\nimport tailwindStylesheetUrl from \\"./styles/tailwind.css\\";\\n\\nexport const links: LinksFunction = () => {\\n  return [\\n    { rel: \\"stylesheet\\", href: tailwindStylesheetUrl },\\n    // We add the fab4m style here.\\n    { rel: \\"stylesheet\\", href: fab4mStyleUrl },\\n  ];\\n};\\n\\nexport const meta: MetaFunction = () => ({\\n  charset: \\"utf-8\\",\\n  title: \\"Remix Notes\\",\\n  viewport: \\"width=device-width,initial-scale=1\\",\\n});\\n\\nexport default function App() {\\n  return (\\n    <html lang=\\"en\\" className=\\"h-full\\">\\n      <head>\\n        <Meta />\\n        <Links />\\n      </head>\\n      <body className=\\"h-full\\">\\n        <Outlet />\\n        <ScrollRestoration />\\n        <Scripts />\\n        <LiveReload />\\n      </body>\\n    </html>\\n  );\\n}\\n```\\n\\nThen change the index.tsx to look like this:\\n\\n```\\nimport { Link } from \\"@remix-run/react\\";\\nexport default function Index() {\\n  const diaries = useLoaderData<Diary[]>();\\n  return (\\n    <main className=\\"relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center\\">\\n      <h1 className=\\"mb-4 text-3xl font-bold\\">Diaries</h1>\\n      <Link\\n        to=\\"diaries/new\\"\\n        className=\\"mb-4 inline-block rounded bg-sky-500 px-4 py-2 font-bold font-medium text-white hover:bg-sky-800\\"\\n      >\\n        Create new diary\\n      </Link>\\n    </main>\\n  );\\n}\\n```\\n\\nNow you should be able to start your app with:\\n\\n```bash\\nnpm run dev\\n```\\n\\nAnd you should see a fairly boring page with a link to a page to create a diary which doesn\'t exist yet.\\n\\n# Set up your diary model with prisma\\n\\nThe indie stack comes with [Prisma](https://www.prisma.io/), a pretty neat Node ORM.\\n\\nOpen your prisma/prisma.schema file. There are some models in there which we won\'t\\nuse, that you can remove if you want. Add our diary model:\\n\\n```prisma\\nmodel Diary {\\n  id    String @id @default(cuid())\\n  title String\\n  body  String\\n  tags  String\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n```\\n\\nThen you can migrate and generate code for the model:\\n\\n```bash\\nnpx prisma db push\\nnpx prisma migrate dev\\n```\\n\\n## Set up your diary server model\\n\\nNow that we have our prisma model we can create an intermediary model to talk to it.\\n\\nCreate `app/models/diary.server.ts` and open it.\\n\\nThen add the following:\\n\\n```jsx\\nimport { Diary as DiaryModel } from \\"@prisma/client\\";\\nimport { prisma } from \\"~/db.server\\";\\n\\n// We export our own Diary interface which is our representation\\n// of the diary that will used inside of our components.\\nexport interface Diary {\\n  id: string;\\n  body: string;\\n  title: string;\\n  tags: string[];\\n}\\n\\n// We export some helper functions to load data from the prisma data layer here.\\n// This allows us to change how this works by only changing this file.\\nexport async function getDiary({\\n  id,\\n}: Pick<DiaryModel, \\"id\\">): Promise<Diary | undefined> {\\n  const diary = await prisma.diary.findFirst({\\n    select: { id: true, body: true, title: true, tags: true },\\n    where: { id },\\n  });\\n  return diary\\n    ? {\\n        ...diary,\\n        tags: JSON.parse(diary?.tags),\\n      }\\n    : undefined;\\n}\\n\\nexport function getDiaries() {\\n  return prisma.diary.findMany({\\n    select: { id: true, title: true, body: true },\\n    orderBy: { updatedAt: \\"desc\\" },\\n  });\\n}\\n\\nexport function createDiary({\\n  body,\\n  title,\\n  tags,\\n}: Pick<Diary, \\"body\\" | \\"title\\"> & {\\n  tags: string[];\\n}) {\\n  return prisma.diary.create({\\n    data: {\\n      title,\\n      body,\\n      tags: JSON.stringify(tags),\\n    },\\n  });\\n}\\n```\\n\\nWe export a few helper functions that we can use to interface with the\\ndatabase across our application.\\n\\n# Set up the diary routes\\n\\nRemix has an automatic routing system that picks up components in the app/routes directory. Let\'s create a new component for representing our form.\\n\\nCreate the file `app/routes/diaries/new.tsx` with the following contents:\\n\\n```bash\\nimport { createForm, tagsWidget, textAreaField, textField } from \\"@fab4m/fab4m\\";\\nimport { StatefulFormRoute } from \\"@fab4m/routerforms\\";\\nimport { Diary } from \\"~/models/diary.server\\";\\n\\nconst form = createForm<Diary>({\\n  title: textField({\\n    label: \\"Title\\",\\n    required: true,\\n  }),\\n  body: textAreaField({\\n    label: \\"Body\\",\\n    required: true,\\n  }),\\n  tags: textField({\\n    label: \\"Tags\\",\\n    multiple: true,\\n    multipleWidget: tagsWidget(),\\n  }),\\n});\\n\\nexport default function NewDiaryPage() {\\n  return (\\n    <main className=\\"relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center\\">\\n      <h1 className=\\"mb-2 text-3xl font-bold\\">Create new diary</h1>\\n      // We use the StatefulFormRoute component here.\\n      // When we set useRouteAction={true} we tell remix to\\n      // manage form submissions from this form.\\n      <StatefulFormRoute form={form} useRouteAction={true} />\\n    </main>\\n  );\\n}\\n```\\n\\nHere we create a basic form to fit our diary model. We type the form with the Diary interface so that we can be sure that the data matches.\\n\\nYou should now be able to visit http://localhost/diaries/new and see the new form!\\n\\n## Saving a diary\\n\\nNow that we have the form in place, we can use a remix action to save it. Make some changes to the new.tsx file:\\n\\n```jsx\\nimport {\\n  createForm,\\n  tagsWidget,\\n  textAreaField,\\n  textField,\\n  fromFormData,\\n} from \\"@fab4m/fab4m\\";\\nimport { StatefulFormRoute } from \\"@fab4m/routerforms\\";\\nimport { useActionData } from \\"@remix-run/react\\";\\nimport { ActionArgs, json } from \\"@remix-run/server-runtime\\";\\nimport { createDiary, Diary } from \\"~/models/diary.server\\";\\n\\nconst form = createForm<Diary>({\\n  title: textField({\\n    label: \\"Title\\",\\n    required: true,\\n  }),\\n  body: textAreaField({\\n    label: \\"Body\\",\\n    required: true,\\n  }),\\n  tags: textField({\\n    label: \\"Tags\\",\\n    multiple: true,\\n    multipleWidget: tagsWidget(),\\n  }),\\n});\\n\\n// This is our new action function.\\nexport async function action({ request }: ActionArgs) {\\n  // The fromFormData transforms the postdata from fab4m into\\n  // the format for our form.\\n  const formData = fromFormData(form, await request.formData());\\n  const diary = await createDiary(formData);\\n  // The diary is passed to the component.\\n  return json(diary);\\n}\\n\\nexport default function NewDiaryPage() {\\n  const diary = useActionData<Diary>();\\n  return (\\n    <main className=\\"relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center\\">\\n      {// Notify the user that the diary has been created.}\\n      {diary && <p>The diary {diary.title} was saved!</p>}\\n      <h1 className=\\"mb-2 text-3xl font-bold\\">Create new diary</h1>\\n      <StatefulFormRoute form={form} useRouteAction={true} />\\n    </main>\\n  );\\n}\\n\\n```\\n\\n## Viewing a diary\\n\\nThe diary has now been saved to the database, so let\'s create a page to view it!\\n\\nCreate the file `app/routes/diaries/$diaryId.tsx`:\\n\\n```\\nimport { Link, useLoaderData } from \\"@remix-run/react\\";\\nimport { getDiary, Diary } from \\"~/models/diary.server\\";\\n\\nexport async function loader({ params }: { params: { diaryId: string } }) {\\n  const diary = await getDiary({ id: params.diaryId });\\n  if (!diary) {\\n    throw new Response(\\"Not Found\\", { status: 404 });\\n  }\\n  return diary;\\n}\\n\\nexport default function DiaryView() {\\n  const diary = useLoaderData<Diary>();\\n  return (\\n    <article className=\\"relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center\\">\\n      <Link to=\\"../../\\" className=\\"mb-4 inline-block text-sky-400\\">\\n        Back\\n      </Link>\\n      <h1 className=\\"mb-2 text-3xl font-bold\\">{diary.title}</h1>\\n      <p className=\\"mb-2\\">{diary.body}</p>\\n      <ul className=\\"flex flex-wrap\\">\\n        {diary.tags.map((tag, i) => (\\n          <li\\n            className=\\"mr-2 rounded bg-sky-500 px-2 px-4 text-sm text-white\\"\\n            key={i}\\n          >\\n            {tag}\\n          </li>\\n        ))}\\n      </ul>\\n    </article>\\n  );\\n}\\n```\\n\\nNow we have a way of viewing our diary! Let\'s change the `app/diaries/new.tsx` to redirect to the new page after creating a diary:\\n\\n```jsx\\n// ...\\nimport { ActionArgs, redirect } from \\"@remix-run/server-runtime\\";\\n// ...\\nexport async function action({ request }: ActionArgs) {\\n  const formData = fromFormData(form, await request.formData());\\n  const diary = await createDiary(formData);\\n  return redirect(`/diaries/${diary.id}`);\\n}\\n```\\n\\nNow, when you create a diary, you will be redirected to the diary page.\\n\\n## Indexing all diaries\\n\\nLet\'s change our app/routes/index.tsx to show a list of all diaries:\\n\\n```jsx\\nimport { Link, useLoaderData } from \\"@remix-run/react\\";\\nimport { Diary, getDiaries } from \\"~/models/diary.server\\";\\n\\nexport function loader() {\\n  return getDiaries();\\n}\\n\\nexport default function Index() {\\n  const diaries = useLoaderData<Diary[]>();\\n  return (\\n    <main className=\\"relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center\\">\\n      <h1 className=\\"mb-4 text-3xl font-bold\\">Diaries</h1>\\n      <Link\\n        to=\\"diaries/new\\"\\n        className=\\"mb-4 inline-block rounded bg-sky-500 px-4 py-2 font-bold font-medium text-white hover:bg-sky-800\\"\\n      >\\n        Create new diary\\n      </Link>\\n      {diaries.map((diary, i) => (\\n        <article key={i}>\\n          <h2 className=\\"mb-2 text-2xl font-bold\\">\\n            <Link to={`diaries/${diary.id}`} className=\\"hover:underline\\">\\n              {diary.title}\\n            </Link>\\n          </h2>\\n          <p className=\\"mb-2\\">{diary.body}</p>\\n        </article>\\n      ))}\\n    </main>\\n  );\\n}\\n```\\n\\n## Adding server side validation\\n\\nYou can\'t be sure the data you receive is fully valid. Luckily fab4m has support\\nfor json schema, which makes validation easy.\\n\\nLet\'s start by installing ajv, a json schema validator:\\n\\n```bash\\nnpm install --save ajv\\n```\\n\\nNow we can add validation to our new.tsx component:\\n\\n```jsx\\nimport {\\n  createForm,\\n  fromFormData,\\n  tagsWidget,\\n  textAreaField,\\n  textField,\\n  generateSchema,\\n} from \\"@fab4m/fab4m\\";\\nimport Ajv from \\"ajv\\";\\nimport { StatefulFormRoute } from \\"@fab4m/routerforms\\";\\nimport { ActionArgs, json, redirect } from \\"@remix-run/server-runtime\\";\\nimport { createDiary, Diary } from \\"~/models/diary.server\\";\\nimport { useActionData } from \\"@remix-run/react\\";\\n\\nconst form = createForm<Diary>({\\n  title: textField({\\n    label: \\"Title\\",\\n    required: true,\\n  }),\\n  body: textAreaField({\\n    label: \\"Body\\",\\n    required: true,\\n  }),\\n  tags: textField({\\n    label: \\"Tags\\",\\n    multiple: true,\\n    multipleWidget: tagsWidget(),\\n  }),\\n});\\n\\n// Initialize ajv and generate the schema for our form.\\nconst ajv = new Ajv();\\nconst validate = ajv.compile(generateSchema(form));\\n\\nexport async function action({ request }: ActionArgs) {\\n  const formData = fromFormData<Diary>(form, await request.formData());\\n  // Validate our form submission, and send back any errors to then\\n  // component if there were any.\\n  const valid = validate(formData);\\n  if (!valid && validate.errors) {\\n    return json({ errors: validate.errors, data: formData });\\n  }\\n  const diary = await createDiary(formData);\\n  return redirect(`/diaries/${diary.id}`);\\n}\\n\\nexport default function NewDiaryPage() {\\n  const actionData = useActionData<typeof action>();\\n\\n  return (\\n    <main className=\\"relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center\\">\\n      <h1 className=\\"mb-2 text-3xl font-bold\\">Create new diary</h1>\\n      // If we have any action data here, then we have errors to print out.\\n      {actionData && (\\n        <ul>\\n          {actionData.errors.map((error, i) => (\\n            <li key={i} className=\\"text-red mb-2\\">\\n              {error.message}\\n            </li>\\n          ))}\\n        </ul>\\n      )}\\n      // Provide the invalid data to the form when it renders.\\n      <StatefulFormRoute\\n        form={form}\\n        data={actionData?.data}\\n        useRouteAction={true}\\n      />\\n    </main>\\n  );\\n}\\n```\\n\\nAnd that\'s it. We now have a fully working remix app with the fab4m goodness built in.\\nThe full source code is available in the [example repository.](https://github.com/fab4m-forms/fab4m-remix-example)"},{"id":"/2022/12/18/form-builder-with-laravel","metadata":{"permalink":"/blog/2022/12/18/form-builder-with-laravel","source":"@site/blog/2022-12-18-form-builder-with-laravel.md","title":"Fab4m and Laravel: Creating a simple form builder","description":"In the previous blog post we got started","date":"2022-12-18T00:00:00.000Z","formattedDate":"December 18, 2022","tags":[],"readingTime":7.985,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"prevItem":{"title":"Remix and fab4m","permalink":"/blog/2023/01/28/remix-with-fab4m"},"nextItem":{"title":"Using fab4m with Laravel and Inertia.js","permalink":"/blog/2022/12/16/fab4m-and-laravel"}},"content":"In the [previous blog post](/blog/2022/12/16/fab4m-and-laravel) we got started\\nwith Laravel and Inertia and showed how we can use Fab4m inside of\\nthis environment to generate our forms.\\n\\nNow let\'s flex our muscles a bit more and create a form builder. This\\nis were fab4m really shines!\\n\\n\x3c!--truncate--\x3e\\n\\n## Create a new model, migration and controller\\n\\nWe start by setting up a new form controller:\\n\\n```bash\\nphp artisan make:model Form -c -m -r\\n```\\n\\nWe start with defining our migration (`database/migrations/[date]_create_forms_table.php`):\\n\\n```php\\npublic function up()\\n{\\n    Schema::create(\'forms\', function (Blueprint $table) {\\n        $table->id();\\n        $table->text(\'title\');\\n        $table->json(\'form\');\\n        $table->text(\'schema\');\\n        $table->timestamps();\\n    });\\n}\\n```\\n\\nWe want to store a title, the form structure and the schema. Notice that we\'re storing\\nthe schema as a string. This is because it\'s easier to store it as a json string, Laravel converts data that comes in to php arrays, which will mess up the schema in certain situations.\\n\\nLet\'s apply the migration, you need to run it through Laravel Sail:\\n\\n```bash\\nvendor/bin/sail artisan migrate\\n```\\n\\nWe also need to adjust our model (`app/Models/Form.php`) to allow us to fill in some fields:\\n\\n```php\\n<?php\\n\\nnamespace App\\\\Models;\\n\\nuse Illuminate\\\\Database\\\\Eloquent\\\\Factories\\\\HasFactory;\\nuse Illuminate\\\\Database\\\\Eloquent\\\\Model;\\n\\nclass Form extends Model\\n{\\n    protected $fillable = [\'title\', \'schema\', \'form\'];\\n\\n    protected $casts = [\\n        \'form\' => \'json\',\\n    ];\\n    use HasFactory;\\n}\\n```\\n\\nLet\'s move on to the controller and set it up to render an Inertia view for creating forms:\\n\\n```php\\npublic function create()\\n{\\n    return Inertia::render(\'Form/Create\', []);\\n}\\n```\\n\\n## Creating a form for creating forms\\n\\nNow for something fun! We\'re going to create a fab4m form for definining\\nother fab4m forms!\\n\\nFab4m is designed to be easily composed together from different parts.\\n\\nHere\'s a \\"Form builder form\\" that exposes some of the options that are available\\nin fab4m:\\n\\n```jsx\\nimport {\\n    createForm,\\n    textFieldType,\\n    textField,\\n    booleanField,\\n    textFieldWidgetType,\\n    textAreaWidgetType,\\n    integerFieldType,\\n    booleanFieldType,\\n    selectWidget,\\n    group,\\n} from \\"@fab4m/fab4m\\";\\n\\nconst fieldTypes = [textFieldType, integerFieldType, booleanFieldType];\\nexport default createForm({\\n    title: textField({ label: \\"Title\\", required: true }),\\n    fields: group(\\n        {\\n            label: \\"Fields\\",\\n            minItems: 1,\\n            multiple: true,\\n        },\\n        {\\n            name: textField({ label: \\"Field name\\", required: true }),\\n            label: textField({ label: \\"Label\\", required: true }),\\n            field: textField({\\n                label: \\"Field type\\",\\n                required: true,\\n                widget: selectWidget(\\n                    fieldTypes.map((field) => [field.name, field.title])\\n                ),\\n            }),\\n            required: booleanField({ label: \\"Required\\" }),\\n            multiple: booleanField({ label: \\"Multiple\\" }),\\n        }\\n    ),\\n});\\n```\\n\\nSome things to unpack here:\\n\\nWe start with importing some component **types** from fab4m. The\\ncomponent type definition is what drives each fab4m component under\\nthe hood. We\'re going to use these definitions to build our final forms.\\n\\nWe then proceed with creating our form based on these component types. We\\ndefine a fab4m group field which represents each field in the form we\\nare creating.  Each field has a name, label field type and options for\\nif the field is required and multiple.\\n\\nLet\'s get back to our Inertia view (`resources/js/Pages/Form/Create.jsx`):\\n\\n```jsx\\nimport GuestLayout from \\"@/Layouts/GuestLayout\\";\\nimport { Inertia } from \\"@inertiajs/inertia\\";\\nimport { Head } from \\"@inertiajs/inertia-react\\";\\nimport \\"@fab4m/fab4m/css/basic/basic.css\\";\\nimport form from \\"../../Forms/Form\\";\\nimport { StatefulFormView } from \\"@fab4m/fab4m\\";\\n\\nexport default function Create() {\\n    form.onSubmit((e, data) => {\\n        e.preventDefault();\\n    });\\n    return (\\n        <GuestLayout>\\n            <Head title=\\"Create new diary\\" />\\n            <h2 className=\\"font-semibold text-xl text-gray-800 leading-tight\\">\\n                Create a new form\\n            </h2>\\n            <div className=\\"py-12\\">\\n                <div className=\\"max-w-7xl mx-auto sm:px-6 lg:px-8 space-y-6\\">\\n                    <StatefulFormView form={form} />\\n                </div>\\n            </div>\\n        </GuestLayout>\\n    );\\n}\\n```\\n\\nGo to [http://localhost/forms/create](http://localhost/forms/create)\\nYou should see our simple form builder!\\n\\n## Saving our form\\n\\nWe now have a form that can generate the form. The next step is to transform\\nthe data from the form into something we can store and then render.\\n\\nWe can accomplish this by creating a fab4m form from the form data we are saving.\\n\\nLet\'s go back to our form file and make a function to transform\\nour data into a full fab4m form:\\n\\n```jsx\\nexport function fab4mFromData(data) {\\n    const form = createForm();\\n    for (const field of data.fields) {\\n        const fieldType = fieldTypes.find(\\n            (type) => type.name === field.fieldType\\n        );\\n        form.add(\\n            formComponent({\\n                type: fieldType,\\n                name: `field_${form.components.length}`,\\n                label: field.label,\\n                required: field.required,\\n                widget: widgets[fieldType.name](),\\n            })\\n        );\\n    }\\n    return serialize(form);\\n}\\n```\\n\\nThis function takes the data from our form and transforms it into a fab4m form.\\nNotice that we serialize the form on the last line. This translates the form\\ninto a format that can be stored as a json structure anywhere and then\\ndeserialized back into a form later.\\n\\nOver in our Create view we can now add our code to save the form back\\nto our endpoint:\\n\\n```jsx\\n...\\nimport { StatefulFormView, generateSchema, serialize } from \\"@fab4m/fab4m\\";\\n...\\nexport default function Create() {\\n    form.onSubmit((e, data) => {\\n        e.preventDefault();\\n        const form = fab4mFromData(data);\\n        Inertia.post(route(\\"forms.store\\"), {\\n            title: data.title,\\n            schema: JSON.stringify(generateSchema(form)),\\n            form: serialize(form),\\n        });\\n    });\\n...\\n```\\n\\nNote that we generate the JSON schema here and send it along to the backend. Note the following:\\n\\n* We are generating the schema for the form above so that it can be\\n  used for validation later.\\n* We use the serialize() function to serialize the form into something that can be\\nstored as a JSON object.\\n\\nLet\'s implement the store function in `app/Http/Controllers/FormController.php` to handle our request:\\n\\n```php\\npublic function store(Request $request)\\n{\\n    $form = Form::create($request->validate([\\n        \'title\' => [\'required\', \'string\'],\\n        \'schema\' => [\'required\', \'array\'],\\n        \'form\' => [\'required\', \'array\'],\\n    ]));\\n    return Redirect::route(\'forms.show\', [$form->id]);\\n}\\n```\\n\\nThis will save our form into the database.\\n\\n:::caution\\nYou need more strict validation than this! This is good enough for a demo,\\nbut it doesn\'t guarantee that the provided data is valid.\\n:::\\n\\n## Viewing the form\\n\\nNow that we saved our form, it\'s time to render it!\\n\\nLet\'s stay in our FormController and add the following to the show function:\\n\\n```php\\npublic function show(Form $form)\\n{\\n    return Inertia::render(\\"Form/Show\\", [\'form\' => $form]);\\n}\\n```\\n\\nBefore we dive into our Page component, let\'s add a new helper function to the Form.jsx file:\\n\\n```jsx\\nexport async function unserializeForm(form) {\\n    return await unserialize(\\n        form,\\n        [textFieldType, booleanFieldType, integerFieldType],\\n        [basic],\\n        [textFieldWidgetType, checkboxWidgetType, numberFieldWidgetType],\\n        [],\\n        [],\\n        []\\n    );\\n}\\n```\\n\\nNow we can render the form in the `resources/js/Pages/Form/Show.jsx`:\\n\\n```jsx\\nimport { useState, useEffect } from \\"react\\";\\nimport GuestLayout from \\"@/Layouts/GuestLayout\\";\\nimport { Inertia } from \\"@inertiajs/inertia\\";\\nimport { Head } from \\"@inertiajs/inertia-react\\";\\nimport \\"@fab4m/fab4m/css/basic/basic.css\\";\\nimport { unserializeForm } from \\"../../Forms/Form\\";\\nimport { StatefulFormView, useForm } from \\"@fab4m/fab4m\\";\\n\\nexport default function Show({ form }) {\\n    const [unserializedForm, changeUnserializedForm] = useState(null);\\n    useEffect(() => {\\n        unserializeForm(form.form).then(changeUnserializedForm);\\n    }, []);\\n    return (\\n        <GuestLayout>\\n            <Head title=\\"Show form\\" />\\n            <h2 className=\\"font-semibold text-xl text-gray-800 leading-tight\\">\\n                Create a new form\\n            </h2>\\n            <div className=\\"py-12\\">\\n                <div className=\\"max-w-7xl mx-auto sm:px-6 lg:px-8 space-y-6\\">\\n                    {unserializedForm && (\\n                        <StatefulFormView form={unserializedForm} />\\n                    )}\\n                </div>\\n            </div>\\n        </GuestLayout>\\n    );\\n}\\n```\\n\\nNormally you wouldn\'t want to unserialize the form within the\\n component, but since this is the entry point for inertia I don\'t\\n think we have a choice.\\n\\nNow, if you head over to\\n[http://localhost/forms/create](http://localhost/forms/create) and\\ncreate a form, you should be redirect to the show page, where your\\nform is shown. That\'s pretty neat!\\n\\n## Saving submissions\\n\\nWe can now render the form, but let\'s take this a step further. Why not deal with handling submissions from any form you fancy creating with our new builder?\\n\\nWe start the usual way, by creating a new model for our submissions:\\n\\n```bash\\nphp artisan make:model FormSubmission -c -m -r\\n```\\n\\nLet\'s start with setting up the migration\\n(`database/migrations/[date]-create_form_submissions_table.php`):\\n\\n```php\\npublic function up()\\n{\\n    Schema::create(\'form_submissions\', function (Blueprint $table) {\\n        $table->id();\\n        $table->foreignId(\'form_id\')->constrained();\\n        $table->json(\'submission\');\\n        $table->timestamps();\\n    });\\n}\\n```\\n\\nAnd then we set up the model (`app/Models/FormSubmission.php`):\\n\\n```php\\n<?php\\n\\nnamespace App\\\\Models;\\n\\nuse Illuminate\\\\Database\\\\Eloquent\\\\Factories\\\\HasFactory;\\nuse Illuminate\\\\Database\\\\Eloquent\\\\Model;\\n\\nclass FormSubmission extends Model\\n{\\n    use HasFactory;\\n    protected $fillable = [\'form_id\', \'submission\'];\\n    protected $casts = [\\n        \'submission\' => \'json\',\\n    ];\\n}\\n```\\n\\nThen, for our controller, let\'s implement the store and show methods:\\n\\n```php\\n...\\nuse Illuminate\\\\Support\\\\Facades\\\\Redirect;\\nuse Inertia\\\\Inertia;\\nuse Opis\\\\JsonSchema\\\\Validator;\\nuse Opis\\\\JsonSchema\\\\Errors\\\\ErrorFormatter;\\n...\\npublic function store(Request $request, Form $form, FormSubmission $formSubmission)\\n{\\n    $validator = new Validator();\\n    $result = $validator->validate((object)$request->get(\'submission\'), $form->schema);\\n    if (!$result->isValid()) {\\n        abort(422, (new ErrorFormatter())->format($result->error()));\\n    }\\n    $submission = FormSubmission::create([\\n        \'form_id\' => $form->id,\\n        \'submission\' => $request->get(\'submission\'),\\n    ]);\\n    return Redirect::route(\'forms.submissions.show\', [$form->id, $submission->id]);\\n}\\n\\npublic function show(Form $form, FormSubmission $submission)\\n{\\n    return Inertia::render(\\"FormSubmission/Show\\", [\'submission\' => $submission]);\\n}\\n```\\n\\nThe magic happens in the `store` method. We validate our incoming request using our\\nJSON Schema validator, and then save our submission.\\n\\nThe `show` method renders an Inertia view to show our submission.\\n\\n## Taking care of our submissions on the frontend\\n\\nLet\'s expand on our `Show` component a bit:\\n\\n```jsx\\n...\\nexport default function Show({ form }) {\\n    const [unserializedForm, changeUnserializedForm] = useState(null);\\n    useEffect(() => {\\n        unserializeForm(form.form).then(changeUnserializedForm);\\n    }, []);\\n    unserializedForm?.onSubmit((e, data) => {\\n        e.preventDefault();\\n        Inertia.post(route(\\"forms.submissions.store\\", [form.id]), {\\n            submission: data,\\n        });\\n    });\\n...\\n```\\n\\nWe add an onSubmit function to the form, and store the data coming through\\nfrom the form.\\n\\nThen in the `resources/js/Pages/FormSubmission/Show.jsx` we add the following:\\n\\n```jsx\\nimport GuestLayout from \\"@/Layouts/GuestLayout\\";\\nimport { Inertia } from \\"@inertiajs/inertia\\";\\nimport { Head, Link } from \\"@inertiajs/inertia-react\\";\\n\\nexport default function Show({ submission }) {\\n    const data = [];\\n    for (const key in submission.submission) {\\n        data.push(\\n            <li key={key}>\\n                <strong>{`${key}: `}</strong>\\n                {submission.submission[key]}\\n            </li>\\n        );\\n    }\\n    return (\\n        <GuestLayout>\\n            <Head title=\\"Submission\\" />\\n            <h2 className=\\"font-semibold text-xl text-gray-800 leading-tight\\">\\n                Submission\\n            </h2>\\n            <div className=\\"py-12\\">\\n                <ul>{data}</ul>\\n            </div>\\n        </GuestLayout>\\n    );\\n}\\n```\\n\\nThis will render the data that was just submitted!\\n\\n## That\'s it\\n\\nThat was a long post! But we accomplished a lot:\\n\\n* We made it possible to create any form and save it along with a schema to validate it.\\n* We made it possible to save submissions for that form.\\n\\nThere are of course tons of features we didn\'t expose here, but it\'s still a nice\\ndemo of how to construct any form you\'d like and validate easily.\\n\\nThe source is available in the [fab4m laravel example repository](https://github.com/fab4m-forms/fab4m-laravel-example)."},{"id":"/2022/12/16/fab4m-and-laravel","metadata":{"permalink":"/blog/2022/12/16/fab4m-and-laravel","source":"@site/blog/2022-12-16-fab4m-and-laravel.md","title":"Using fab4m with Laravel and Inertia.js","description":"This is the first part in a blog series about how you can use fab4m together","date":"2022-12-16T00:00:00.000Z","formattedDate":"December 16, 2022","tags":[],"readingTime":6.73,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"prevItem":{"title":"Fab4m and Laravel: Creating a simple form builder","permalink":"/blog/2022/12/18/form-builder-with-laravel"},"nextItem":{"title":"Hello world!","permalink":"/blog/2022/12/11/hello-world"}},"content":"This is the first part in a blog series about how you can use fab4m together\\nwith different backend frameworks.\\n\\nAt my workplace ([Leanlab.co](https://leanlab.co/)) we use Laravel as our web framework and we are veryhappy with it. That\'s why it\'s only natural to start there!\\n\\nIn this blog post we are going to set up a laravel installation with\\n[Laravel\\nbreeze](https://laravel.com/docs/9.x/starter-kits#laravel-breeze), a\\nstarter kit for laravel that provides you with a solid boilerplate to\\nstart building any app.\\n\\nTo get things integrated with react we are using [Inertja.js](https://inertiajs.com/), a way to easily tie your react frontend together with your backend.\\n\\n\x3c!--truncate--\x3e\\n\\n## Installing laravel\\n\\nHave a look at the [Laravel installation guide](https://laravel.com/docs/9.x/installation) for the full details,\\nbut in short, if you have [php](https://php.net), [composer](https://getcomposer.org/) and [node](https://nodejs.org/en/) installed you can go ahead:\\n\\n```bash\\ncomposer create-project laravel/laravel fab4m-example\\n```\\n\\nThis will get you started with a blank laravel project.\\n\\n## Getting everything in place with docker\\n\\nI usually work with docker to get things like mysql and other related services going.\\n    Luckily laravel provides us with an easy way to do that called [laravel sail](https://laravel.com/docs/9.x/sail):\\n\\n```bash\\ncomposer require laravel/sail --dev\\nphp artisan sail:install\\n```\\n\\nThis will install laravel sail and get everything configured for you!\\n\\nNow you can run:\\n\\n```bash\\nvendor/bin/sail up -d\\n```\\n\\nTo get your full environment up and running.\\n\\nNow, browse to http://localhost you should see your environment up and running!\\n\\n## Setting up laravel breeze\\n\\nLaravel breeze gives us a flying start with authentication and a nice setup\\nto get you going with React. The starter kit gets you going with all the tooling\\nyou need, pretty neat!\\n\\n```bash\\ncomposer require laravel/breeze --dev\\nphp artisan breeze:install react\\n```\\n\\n## Running the migrations\\n\\nLaravel breeze provides you with a user model for authentication.\\nYou can get the schema installed by migrating:\\n\\n```bash\\nvendor/bin/sail artisan migrate\\n```\\n\\n## Try it out\\n\\nVisit: [http://localhost/register](http://localhost/register)\\n\\nYou should see a form to register and you can perform the registration process!\\n\\n## Install fab4m\\n\\nNow it\'s time for the fun part, let\'s see how we can use fab4m to complement\\nour already amazing stack! Let\'s begin by installing it:\\n\\n```bash\\nnpm install --save @fab4m/fab4m\\n```\\n\\n## Make a diary model, migration and controller\\n\\nLaravel provides us with a nice way of generating a lot of boilerplate code.\\n\\nThe following command creates:\\n* A [Laravel model](https://laravel.com/docs/9.x/eloquent) for our diary posts\\n* A [Laravel migration](https://laravel.com/docs/9.x/migrations) for setting up the diary schema\\n* A [Laravel resource controller](https://laravel.com/docs/9.x/controllers#resource-controllers) for handling our CRUD operations.\\n\\n```bash\\nphp artisan make:model Diary -c -m -r\\n```\\n\\n## Let\'s fill in the blanks!\\n\\nNow we have some actual coding to do, finally!\\n\\nLet\'s start with our migration,there should be a file called [date]-create_diaries_table.php in your database/migrations folder, edit the `up()` function to this:\\n\\n```php\\npublic function up()\\n{\\n    Schema::create(\'diaries\', function (Blueprint $table) {\\n        $table->id();\\n        $table->text(\'title\');\\n        $table->text(\'body\');\\n        $table->json(\'tags\')->nullable();\\n        $table->timestamps();\\n    });\\n}\\n```\\n\\nThis will create a database table with a title and body text field and a json field for storing tags for the diaries.\\n\\nNext up, edit your model (`app/Models/Diary.php`) a bit:\\n\\n```php\\nclass Diary extends Model\\n{\\n    use HasFactory;\\n\\n    protected $fillable = [\'title\', \'body\', \'tags\'];\\n    protected $casts = [\'tags\' => \'json\'];\\n}\\n```\\n\\nThis will make the title, body and tags fillable when saving data.\\nWe also indicate that the tags is json data so that it will be properly handled.\\n\\nThen edit our controller to render an inertia javascript page for showing our form:\\n\\n```php\\npublic function create()\\n{\\n    return Inertia::render(\'Diary/Create\', []);\\n}\\n```\\n\\nFinally we need to register our new resource controller among our routes, this is done in routes/web.php file:\\n\\n```php\\nRoute::resource(\'diaries\', DiaryController::class);\\n```\\n\\nWe\'re ready to render our form on the client side!\\n\\n## Setting up the fab4m form\\n\\nLet\'s start with creating a fab4m form, create a file in resources/js/Forms/Diary.js:\\n\\n```jsx\\nimport {\\n    createForm,\\n    textField,\\n    textAreaWidget,\\n    tagsWidget,\\n} from \\"@fab4m/fab4m\\";\\n\\nexport default createForm({\\n    title: textField({ label: \\"Title\\", required: true }),\\n    body: textField({\\n        label: \\"Body\\",\\n        required: true,\\n        widget: textAreaWidget(),\\n    }),\\n    tags: textField({\\n        label: \\"Tags\\",\\n        multiple: true,\\n        multipleWidget: tagsWidget(),\\n    }),\\n});\\n```\\n\\nWe create a simple form with a title and a body field, and we spice it up\\nwith an autocomplete tags field. This allows us to re-use the form wherever we like.\\n\\nWith the form in hand we can now create our first Inertia page. Create the file `resources/js/Pages/Diary/Create.jsx`:\\n\\n```jsx\\nimport GuestLayout from \\"@/Layouts/GuestLayout\\";\\nimport { Inertia } from \\"@inertiajs/inertia\\";\\nimport { Head } from \\"@inertiajs/inertia-react\\";\\nimport \\"@fab4m/fab4m/css/basic/basic.css\\";\\nimport form from \\"../../Forms/Diary\\";\\nimport { StatefulFormView } from \\"@fab4m/fab4m\\";\\n\\nexport default function Create() {\\n    form.onSubmit((e, data) => {\\n        e.preventDefault();\\n        Inertia.post(route(\\"diaries.store\\"), data);\\n    });\\n    return (\\n        <GuestLayout>\\n            <Head title=\\"Create new diary\\" />\\n            <h2 className=\\"font-semibold text-xl text-gray-800 leading-tight\\">\\n                Create new diary\\n            </h2>\\n            <div className=\\"py-12\\">\\n                <div className=\\"max-w-7xl mx-auto sm:px-6 lg:px-8 space-y-6\\">\\n                    <StatefulFormView form={form} />\\n                </div>\\n            </div>\\n        </GuestLayout>\\n    );\\n}\\n```\\n\\nNotice that we add an `onSubmit()` handler on the form. That handler is then used\\nto submit our data back to laravel.\\n\\nThe GuestLayout is provided by the breeze boilerplate and provides\\na basic header and footer. The real magic happens in our StatefulFormView where\\nwe render the form. We use the `StatefulFormView` component to render the form.\\nThe state is then handled internally.\\n\\nVisit [http://localhost/diaries/create](http://localhost/diaries/create)\\n\\nYou should see our newly created form in action, and if you submit the\\nform you will be presented with an error that your method for creating\\nyour diary isn\'t returning anything.\\n\\n## Saving your laravel model\\n\\nHead over to `app/Http/Controllers/DiaryController.php`and add the following to your `store` method:\\n\\n```php\\nuse use Illuminate\\\\Http\\\\Request;\\nuse Illuminate\\\\Support\\\\Facades\\\\Redirect;\\n\\n...\\n\\npublic function store(Request $request)\\n{\\n    $diary = Diary::create($request->validate([\\n          \'title\' => [\'required\', \'string\'],\\n          \'body\' => [\'required\', \'string\'],\\n          \'tags\' => [\'nullable\', \'array\'],\\n       ]));\\n     return Redirect::route(\'diaries.show\', [$diary->id]);\\n}\\n```\\n\\nOnce the form is saved you will be redirected to the show page. That page can be implemented the same way as the create page:\\n\\n```php\\npublic function show(Diary $diary)\\n{\\n    return Inertia::render(\'Diary/Show\', [\'diary\' => $diary]);\\n}\\n```\\n\\nNotice that we\'re sending the diary along. This diary is then available in the page component, `resources/views/js/Pages/Show.jsx`:\\n\\n```jsx\\nimport GuestLayout from \\"@/Layouts/GuestLayout\\";\\nimport { Inertia } from \\"@inertiajs/inertia\\";\\nimport { Head, Link } from \\"@inertiajs/inertia-react\\";\\n\\nexport default function Show({ diary }) {\\n    return (\\n        <GuestLayout>\\n            <Head title={diary.title} />\\n            <h2 className=\\"font-semibold text-xl text-gray-800 leading-tight\\">\\n                Diary: {diary.title}\\n            </h2>\\n            <div className=\\"py-12\\">\\n                <article className=\\"max-w-7xl mx-auto sm:px-6 lg:px-8 space-y-6\\">\\n                    <h3 class=\\"font-bold\\">Entry</h3>\\n                    <p className=\\"mb-4\\">{diary.body}</p>\\n                    <h3 class=\\"font-bold\\">Tags</h3>\\n                    <ul className=\\"list-disc ml-8 mt-1\\">\\n                        {diary.tags.map((tag, i) => (\\n                            <li key={i}>{tag}</li>\\n                        ))}\\n                    </ul>\\n                    <Link\\n                        className=\\"text-blue-700\\"\\n                        href={route(\\"diaries.edit\\", [diary.id])}\\n                    >\\n                        Edit\\n                    </Link>\\n                </article>\\n            </div>\\n        </GuestLayout>\\n    );\\n}\\n```\\n\\n## And that\'s it!\\n\\nWe have a working example. If the form is this basic, you probably want to\\nstick with Laravel validation, but if you want to utilize the full power of fab4m,\\nyou can use JSON schema instead to validate your submission. Let\'s explode how that would look like.\\n\\n## Generating the JSON Schema\\n\\nYou can generate a json schema from any form by using the `generateSchema` function:\\n\\n```jsx\\nconsole.log(JSON.stringify(generateSchema(form)));\\n```\\n\\nThe output from this function will be the json schema that you can use to validate your form anywhere.\\n\\nAdd the schema to your function:\\n```php\\nclass DiaryController extends Controller\\n{\\n    private string $schema = <<<JSON\\n{\\"title\\":\\"Form data\\",\\"description\\":\\"A form submission\\",\\"type\\":\\"object\\",\\"properties\\":{\\"title\\":{\\"type\\":\\"string\\",\\"title\\":\\"Title\\",\\"minLength\\":1},\\"body\\":{\\"type\\":\\"string\\",\\"title\\":\\"Title\\",\\"minLength\\":1},\\"tags\\":{\\"type\\":\\"array\\",\\"title\\":\\"Tags\\",\\"items\\":{\\"type\\":\\"string\\",\\"title\\":\\"Tags\\"},\\"minItems\\":0}},\\"required\\":[\\"title\\",\\"body\\"],\\"dependencies\\":{}}\\nJSON;\\n\\n...\\n\\n}\\n```\\n\\nWith the schema in place, you can use any json schema validator to validate it. Here we use the [opis json-schema package](https://opis.io/json-schema):\\n\\n```bash\\ncomposer require opis/json-schema\\n```\\n\\n## Using the JSON schema for validation\\n\\nNow that we have our schema available we can use the json schema validator\\ninstead of the native laravel validation to do the work for us:\\n\\n```php\\npublic function store(Request $request)\\n{\\n  $validator = new Validator();\\n  $result = $validator->validate((object)$request->all(), $this->schema);\\n  if (!$result->isValid()) {\\n    abort(422, (new ErrorFormatter())->format($result->error()));\\n  }\\n  $diary = Diary::create(\\n    $request->all();\\n  );\\n  return Redirect::route(\\"diaries.show\\", [$diary->id]);\\n}\\n```\\n\\n## That\'s a wrap!\\n\\nThis is an example of how to integrate fab4m into a Laravel app.\\nThis example wasn\'t particularly exciting in terms of form building,\\nso in the next blog post I will expand on this application to include\\nsomething that would be more of a challenge!\\n\\nThe full source code for this blog post is available [here](https://github.com/fab4m-forms/fab4m-laravel-example)."},{"id":"/2022/12/11/hello-world","metadata":{"permalink":"/blog/2022/12/11/hello-world","source":"@site/blog/2022-12-11-hello-world.md","title":"Hello world!","description":"It\'s been a long time coming, but I finally released the first beta of","date":"2022-12-11T00:00:00.000Z","formattedDate":"December 11, 2022","tags":[],"readingTime":1.325,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"prevItem":{"title":"Using fab4m with Laravel and Inertia.js","permalink":"/blog/2022/12/16/fab4m-and-laravel"}},"content":"It\'s been a long time coming, but I finally released the first beta of\\nfab4m, a better way to work with forms!\\n\\nWhen working with development I always find dealing with forms to be\\nthe most time consuming and tedious part of any project. There are\\nmany solutions out there, but they tend to tailor to only part of the\\nproblem: validation, rendering, and so on.\\n\\nI set out to finally solve the problem once and for all. It took way\\nmore time than I anticipated, but here it is!\\n\\n\x3c!--truncate--\x3e\\n\\nWhat are the highlights then?\\n\\nInstead of working directly with markup, you structure your form using a javascript object:\\n\\n```jsx\\nimport { createForm } from \\"@fab4m/fab4m\\";\\nconst form = createForm({\\n    title: textField({ label: \\"Title\\" }),\\n});\\n```\\n\\nThis makes it easy to build your structure however you like without having to think about how to structure the markup.\\n\\nThe form is made up from [components](/docs/guide/define-a-form). The component describes one part of the form and the data that it contains.\\n\\nEach component can have different widgets. The widget is responsible for rendering the component:\\n\\n```\\nconst form = createForm({\\n    title: textField({ label: \\"Title\\", widget: optionsWidget({}, [\\"one\\", \\"two\\"] }),\\n});\\n```\\n\\n\\nIn addition to this there\'s also [validators](/docs/guide/validators) and visibility rules to make it easy to validate your form.\\n\\nFab4m allows you to easily validate form submissions anywhere. You can generate a [JSON Schema](https://json-schema.org/) from any form.\\n\\nThe whole form structure can be [serialized](/docs/guide/serializing) so that it can\\nbe stored easily.\\n\\nThere are many more features, have a look in the [docs](/docs/intro) and try it out!"}]}')}}]);