"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[891],{336:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var n=a(7462),r=(a(7294),a(3905));const i={title:"Remix and fab4m",description:"Remix and fab4m work great together thanks to it's compatibility with react router. Let's dive in!"},o="Remix and fab4m",s={permalink:"/blog/2023/01/28/remix-with-fab4m",source:"@site/blog/2023-01-28-remix-with-fab4m.md",title:"Remix and fab4m",description:"Remix and fab4m work great together thanks to it's compatibility with react router. Let's dive in!",date:"2023-01-28T00:00:00.000Z",formattedDate:"January 28, 2023",tags:[],readingTime:8.66,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Remix and fab4m",description:"Remix and fab4m work great together thanks to it's compatibility with react router. Let's dive in!"},prevItem:{title:"Tailwind theme for fab4m",permalink:"/blog/2023/04/28/tailwind-theme"},nextItem:{title:"Fab4m and Laravel: Creating a simple form builder",permalink:"/blog/2022/12/18/form-builder-with-laravel"}},l={authorsImageUrls:[]},m=[{value:"Set up a new remix project",id:"set-up-a-new-remix-project",level:2},{value:"Clean up the boiler plate",id:"clean-up-the-boiler-plate",level:2},{value:"Set up your diary server model",id:"set-up-your-diary-server-model",level:2},{value:"Saving a diary",id:"saving-a-diary",level:2},{value:"Viewing a diary",id:"viewing-a-diary",level:2},{value:"Indexing all diaries",id:"indexing-all-diaries",level:2},{value:"Adding server side validation",id:"adding-server-side-validation",level:2}],d={toc:m};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://remix.run/"},"Remix")," is a great node framework to render react components server side. It\ncomes with some really great ways of handling loading and saving data and\nit has recently become completely compatible with the popular ",(0,r.kt)("a",{parentName:"p",href:"https://reactrouter.com/en/main"},"React Router")," library."),(0,r.kt)("p",null,"Fab4m comes with a support package to support react router which means\nit also works with remix. This let's you offload a lot of the work\nthat is normally done on the client to the server side!"),(0,r.kt)("p",null,"This blog post illustrates how fab4m can be used together with Remix.\nI won't go into great detail on how remix works, for that you can\ncheck their excellent documentation!"),(0,r.kt)("h2",{id:"set-up-a-new-remix-project"},"Set up a new remix project"),(0,r.kt)("p",null,"Remix comes with a few different stacks. We're going to use the indie stack\nhere which is really easy to get started with since it relies only on sqlite."),(0,r.kt)("p",null,"npx create-remix@latest --template remix-run/indie-stack fab4m-remix"),(0,r.kt)("h2",{id:"clean-up-the-boiler-plate"},"Clean up the boiler plate"),(0,r.kt)("p",null,"The boilerplate code comes with some neat things that we don't need in this simple app, like an example entry model and authentication. We're going to start with stripping that out."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"rm -r app/routes/notes/\napp/routes/notes.tsx\napp/routes/join.tsx\napp/routes/login.tsx\napp/routes/logout.tsx\napp/models/note.server.ts\napp/models/user.server.ts\napp/session.server.ts\napp/utils.ts\napp/utils.test.ts\n")),(0,r.kt)("p",null,"change root.tsx so that it looks like this, not that we also added the fab4m stylesheet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import type { LinksFunction, LoaderArgs, MetaFunction } from "@remix-run/node";\nimport {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from "@remix-run/react";\nimport fab4mStyleUrl from "@fab4m/fab4m/css/basic/basic.css";\nimport tailwindStylesheetUrl from "./styles/tailwind.css";\n\nexport const links: LinksFunction = () => {\n  return [\n    { rel: "stylesheet", href: tailwindStylesheetUrl },\n    // We add the fab4m style here.\n    { rel: "stylesheet", href: fab4mStyleUrl },\n  ];\n};\n\nexport const meta: MetaFunction = () => ({\n  charset: "utf-8",\n  title: "Remix Notes",\n  viewport: "width=device-width,initial-scale=1",\n});\n\nexport default function App() {\n  return (\n    <html lang="en" className="h-full">\n      <head>\n        <Meta />\n        <Links />\n      </head>\n      <body className="h-full">\n        <Outlet />\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  );\n}\n')),(0,r.kt)("p",null,"Then change the index.tsx to look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'import { Link } from "@remix-run/react";\nexport default function Index() {\n  const diaries = useLoaderData<Diary[]>();\n  return (\n    <main className="relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center">\n      <h1 className="mb-4 text-3xl font-bold">Diaries</h1>\n      <Link\n        to="diaries/new"\n        className="mb-4 inline-block rounded bg-sky-500 px-4 py-2 font-bold font-medium text-white hover:bg-sky-800"\n      >\n        Create new diary\n      </Link>\n    </main>\n  );\n}\n')),(0,r.kt)("p",null,"Now you should be able to start your app with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm run dev\n")),(0,r.kt)("p",null,"And you should see a fairly boring page with a link to a page to create a diary which doesn't exist yet."),(0,r.kt)("h1",{id:"set-up-your-diary-model-with-prisma"},"Set up your diary model with prisma"),(0,r.kt)("p",null,"The indie stack comes with ",(0,r.kt)("a",{parentName:"p",href:"https://www.prisma.io/"},"Prisma"),", a pretty neat Node ORM."),(0,r.kt)("p",null,"Open your prisma/prisma.schema file. There are some models in there which we won't\nuse, that you can remove if you want. Add our diary model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-prisma"},"model Diary {\n  id    String @id @default(cuid())\n  title String\n  body  String\n  tags  String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n")),(0,r.kt)("p",null,"Then you can migrate and generate code for the model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npx prisma db push\nnpx prisma migrate dev\n")),(0,r.kt)("h2",{id:"set-up-your-diary-server-model"},"Set up your diary server model"),(0,r.kt)("p",null,"Now that we have our prisma model we can create an intermediary model to talk to it."),(0,r.kt)("p",null,"Create ",(0,r.kt)("inlineCode",{parentName:"p"},"app/models/diary.server.ts")," and open it."),(0,r.kt)("p",null,"Then add the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Diary as DiaryModel } from "@prisma/client";\nimport { prisma } from "~/db.server";\n\n// We export our own Diary interface which is our representation\n// of the diary that will used inside of our components.\nexport interface Diary {\n  id: string;\n  body: string;\n  title: string;\n  tags: string[];\n}\n\n// We export some helper functions to load data from the prisma data layer here.\n// This allows us to change how this works by only changing this file.\nexport async function getDiary({\n  id,\n}: Pick<DiaryModel, "id">): Promise<Diary | undefined> {\n  const diary = await prisma.diary.findFirst({\n    select: { id: true, body: true, title: true, tags: true },\n    where: { id },\n  });\n  return diary\n    ? {\n        ...diary,\n        tags: JSON.parse(diary?.tags),\n      }\n    : undefined;\n}\n\nexport function getDiaries() {\n  return prisma.diary.findMany({\n    select: { id: true, title: true, body: true },\n    orderBy: { updatedAt: "desc" },\n  });\n}\n\nexport function createDiary({\n  body,\n  title,\n  tags,\n}: Pick<Diary, "body" | "title"> & {\n  tags: string[];\n}) {\n  return prisma.diary.create({\n    data: {\n      title,\n      body,\n      tags: JSON.stringify(tags),\n    },\n  });\n}\n')),(0,r.kt)("p",null,"We export a few helper functions that we can use to interface with the\ndatabase across our application."),(0,r.kt)("h1",{id:"set-up-the-diary-routes"},"Set up the diary routes"),(0,r.kt)("p",null,"Remix has an automatic routing system that picks up components in the app/routes directory. Let's create a new component for representing our form."),(0,r.kt)("p",null,"Create the file ",(0,r.kt)("inlineCode",{parentName:"p"},"app/routes/diaries/new.tsx")," with the following contents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'import { createForm, tagsWidget, textAreaField, textField } from "@fab4m/fab4m";\nimport { StatefulFormRoute } from "@fab4m/routerforms";\nimport { Diary } from "~/models/diary.server";\n\nconst form = createForm<Diary>({\n  title: textField({\n    label: "Title",\n    required: true,\n  }),\n  body: textAreaField({\n    label: "Body",\n    required: true,\n  }),\n  tags: textField({\n    label: "Tags",\n    multiple: true,\n    multipleWidget: tagsWidget(),\n  }),\n});\n\nexport default function NewDiaryPage() {\n  return (\n    <main className="relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center">\n      <h1 className="mb-2 text-3xl font-bold">Create new diary</h1>\n      // We use the StatefulFormRoute component here.\n      // When we set useRouteAction={true} we tell remix to\n      // manage form submissions from this form.\n      <StatefulFormRoute form={form} useRouteAction={true} />\n    </main>\n  );\n}\n')),(0,r.kt)("p",null,"Here we create a basic form to fit our diary model. We type the form with the Diary interface so that we can be sure that the data matches."),(0,r.kt)("p",null,"You should now be able to visit http://localhost/diaries/new and see the new form!"),(0,r.kt)("h2",{id:"saving-a-diary"},"Saving a diary"),(0,r.kt)("p",null,"Now that we have the form in place, we can use a remix action to save it. Make some changes to the new.tsx file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import {\n  createForm,\n  tagsWidget,\n  textAreaField,\n  textField,\n  fromFormData,\n} from "@fab4m/fab4m";\nimport { StatefulFormRoute } from "@fab4m/routerforms";\nimport { useActionData } from "@remix-run/react";\nimport { ActionArgs, json } from "@remix-run/server-runtime";\nimport { createDiary, Diary } from "~/models/diary.server";\n\nconst form = createForm<Diary>({\n  title: textField({\n    label: "Title",\n    required: true,\n  }),\n  body: textAreaField({\n    label: "Body",\n    required: true,\n  }),\n  tags: textField({\n    label: "Tags",\n    multiple: true,\n    multipleWidget: tagsWidget(),\n  }),\n});\n\n// This is our new action function.\nexport async function action({ request }: ActionArgs) {\n  // The fromFormData transforms the postdata from fab4m into\n  // the format for our form.\n  const formData = fromFormData(form, await request.formData());\n  const diary = await createDiary(formData);\n  // The diary is passed to the component.\n  return json(diary);\n}\n\nexport default function NewDiaryPage() {\n  const diary = useActionData<Diary>();\n  return (\n    <main className="relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center">\n      {// Notify the user that the diary has been created.}\n      {diary && <p>The diary {diary.title} was saved!</p>}\n      <h1 className="mb-2 text-3xl font-bold">Create new diary</h1>\n      <StatefulFormRoute form={form} useRouteAction={true} />\n    </main>\n  );\n}\n\n')),(0,r.kt)("h2",{id:"viewing-a-diary"},"Viewing a diary"),(0,r.kt)("p",null,"The diary has now been saved to the database, so let's create a page to view it!"),(0,r.kt)("p",null,"Create the file ",(0,r.kt)("inlineCode",{parentName:"p"},"app/routes/diaries/$diaryId.tsx"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'import { Link, useLoaderData } from "@remix-run/react";\nimport { getDiary, Diary } from "~/models/diary.server";\n\nexport async function loader({ params }: { params: { diaryId: string } }) {\n  const diary = await getDiary({ id: params.diaryId });\n  if (!diary) {\n    throw new Response("Not Found", { status: 404 });\n  }\n  return diary;\n}\n\nexport default function DiaryView() {\n  const diary = useLoaderData<Diary>();\n  return (\n    <article className="relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center">\n      <Link to="../../" className="mb-4 inline-block text-sky-400">\n        Back\n      </Link>\n      <h1 className="mb-2 text-3xl font-bold">{diary.title}</h1>\n      <p className="mb-2">{diary.body}</p>\n      <ul className="flex flex-wrap">\n        {diary.tags.map((tag, i) => (\n          <li\n            className="mr-2 rounded bg-sky-500 px-2 px-4 text-sm text-white"\n            key={i}\n          >\n            {tag}\n          </li>\n        ))}\n      </ul>\n    </article>\n  );\n}\n')),(0,r.kt)("p",null,"Now we have a way of viewing our diary! Let's change the ",(0,r.kt)("inlineCode",{parentName:"p"},"app/diaries/new.tsx")," to redirect to the new page after creating a diary:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'// ...\nimport { ActionArgs, redirect } from "@remix-run/server-runtime";\n// ...\nexport async function action({ request }: ActionArgs) {\n  const formData = fromFormData(form, await request.formData());\n  const diary = await createDiary(formData);\n  return redirect(`/diaries/${diary.id}`);\n}\n')),(0,r.kt)("p",null,"Now, when you create a diary, you will be redirected to the diary page."),(0,r.kt)("h2",{id:"indexing-all-diaries"},"Indexing all diaries"),(0,r.kt)("p",null,"Let's change our app/routes/index.tsx to show a list of all diaries:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Link, useLoaderData } from "@remix-run/react";\nimport { Diary, getDiaries } from "~/models/diary.server";\n\nexport function loader() {\n  return getDiaries();\n}\n\nexport default function Index() {\n  const diaries = useLoaderData<Diary[]>();\n  return (\n    <main className="relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center">\n      <h1 className="mb-4 text-3xl font-bold">Diaries</h1>\n      <Link\n        to="diaries/new"\n        className="mb-4 inline-block rounded bg-sky-500 px-4 py-2 font-bold font-medium text-white hover:bg-sky-800"\n      >\n        Create new diary\n      </Link>\n      {diaries.map((diary, i) => (\n        <article key={i}>\n          <h2 className="mb-2 text-2xl font-bold">\n            <Link to={`diaries/${diary.id}`} className="hover:underline">\n              {diary.title}\n            </Link>\n          </h2>\n          <p className="mb-2">{diary.body}</p>\n        </article>\n      ))}\n    </main>\n  );\n}\n')),(0,r.kt)("h2",{id:"adding-server-side-validation"},"Adding server side validation"),(0,r.kt)("p",null,"You can't be sure the data you receive is fully valid. Luckily fab4m has support\nfor json schema, which makes validation easy."),(0,r.kt)("p",null,"Let's start by installing ajv, a json schema validator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save ajv\n")),(0,r.kt)("p",null,"Now we can add validation to our new.tsx component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import {\n  createForm,\n  fromFormData,\n  tagsWidget,\n  textAreaField,\n  textField,\n  generateSchema,\n} from "@fab4m/fab4m";\nimport Ajv from "ajv";\nimport { StatefulFormRoute } from "@fab4m/routerforms";\nimport { ActionArgs, json, redirect } from "@remix-run/server-runtime";\nimport { createDiary, Diary } from "~/models/diary.server";\nimport { useActionData } from "@remix-run/react";\n\nconst form = createForm<Diary>({\n  title: textField({\n    label: "Title",\n    required: true,\n  }),\n  body: textAreaField({\n    label: "Body",\n    required: true,\n  }),\n  tags: textField({\n    label: "Tags",\n    multiple: true,\n    multipleWidget: tagsWidget(),\n  }),\n});\n\n// Initialize ajv and generate the schema for our form.\nconst ajv = new Ajv();\nconst validate = ajv.compile(generateSchema(form));\n\nexport async function action({ request }: ActionArgs) {\n  const formData = fromFormData<Diary>(form, await request.formData());\n  // Validate our form submission, and send back any errors to then\n  // component if there were any.\n  const valid = validate(formData);\n  if (!valid && validate.errors) {\n    return json({ errors: validate.errors, data: formData });\n  }\n  const diary = await createDiary(formData);\n  return redirect(`/diaries/${diary.id}`);\n}\n\nexport default function NewDiaryPage() {\n  const actionData = useActionData<typeof action>();\n\n  return (\n    <main className="relative m-auto mt-10 min-h-screen w-1/2 rounded bg-slate-200 bg-white p-4 sm:items-center">\n      <h1 className="mb-2 text-3xl font-bold">Create new diary</h1>\n      // If we have any action data here, then we have errors to print out.\n      {actionData && (\n        <ul>\n          {actionData.errors.map((error, i) => (\n            <li key={i} className="text-red mb-2">\n              {error.message}\n            </li>\n          ))}\n        </ul>\n      )}\n      // Provide the invalid data to the form when it renders.\n      <StatefulFormRoute\n        form={form}\n        data={actionData?.data}\n        useRouteAction={true}\n      />\n    </main>\n  );\n}\n')),(0,r.kt)("p",null,"And that's it. We now have a fully working remix app with the fab4m goodness built in.\nThe full source code is available in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/fab4m-forms/fab4m-remix-example"},"example repository.")))}u.isMDXComponent=!0}}]);